---
title: "Time Series Forecasting"
author: "Jose Zuniga"
output:
  html_document:
    toc: yes
    toc_depth: 2
  word_document:
    toc: yes
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Overview

This project covers material in *Forecasting: Principles and Practice* by Hyndman and Athanasopoulos.

> [The project is] a time series forecasting assignment. You [are] given a data set with basic information and basic objectives. Very much like a busy boss that does not have time to spell everything out. You can add your creativity. You can use additional tools beside R (however you should use some R). You will want to come up with a very nice report that is readable in Word. I care about technical accuracy, but presentation matters! I used think flash and flare were false and fake for analysts without substance. While I still think that (to a lesser extent), so what! It does in the real world! There are many things in the world or system that we don't agree with, but that is reality. You have to work within the system. So, oftentimes your job output will be judged on flash as well as technical accuracy, so be good at both. [This is a] single Effort, no interaction with others outside of meetups on this assignment.

**Submission**: Word readable document for report (all in one), Excel readable for outputs (all in one, separate sheets).

# System Setup

```{r eval=F}
if (!require("xts")) install.packages("xts")
if (!require("xlsx")) install.packages("xlsx")
if (!require("tseries")) install.packages("tseries")
if (!require("forecast")) install.packages("forecast")
```

To use the `xlsx` package on Linux, `RJava` and `Rgdal` must be installed.

```{bash eval=F}
sudo apt-get update
sudo apt-get install default-jre # Install Java
sudo apt-get install default-jdk # Install JDK
sudo R CMD javareconf # Assotiate the JDK installed with R
sudo apt-get install r-cran-rjava # Install RJava
sudo apt-get install libgdal-dev libproj-dev # Install Rgdal
```

# ATM Forecast

In part A, I want you to forecast how much cash is taken out of 4 different ATM machines for May 2010. The data is given in a single file. The variable 'Cash' is provided in hundreds of dollars, other than that it is straight forward. I am being somewhat ambiguous on purpose. I am giving you data, please provide your written report on your findings, visuals, discussion and your R code all within a Word readable document, except the forecast which you will put in an Excel readable file.  I must be able to cut and paste your R code and run it in R studio or other interpreter.

## Import Data

There are several packages for importing Excel files into R. The native method in `r R.Version()$version.string` uses the `readxl` package. The `readxl` library translates Excel cell/column `date` types into R `POSIXct` types. This enhanced date format is not compatible with the current version of many packages. The `read.xls()` function from the ` openxlsx` package does not currently support https. It therefore requires use of `gsub()`. The `xlsx` package is versatile and has a function to write files which is needed for exporting results.

```{r warning=F, message=F, cache=T}
github <- "https://raw.githubusercontent.com/jzuniga123"
file <- "/SPS/master/DATA%20624/ATM624Data.xlsx"
download.file(paste0(github, file), "temp.xlsx", mode="wb")
atm <- xlsx::read.xlsx("temp.xlsx", sheetIndex=1, header=T)
invisible(file.remove("temp.xlsx"))
```

## Explore Data

The Time Series data are first explored through number summaries and visualizations.

### Number Summaries

The `summary()` function provides descriptive statistics on quantitative and qualitative variables. The `xts::preiodocity()` function describes the periods of the dates in the time series. The `complete.cases()` function returns observations in the datasets that have no missing values.

```{r warning=F, message=F, fig.align='center', cache=T}
summary(atm)
xts::periodicity(unique(atm$DATE)) # sampling Frequency
atm[!complete.cases(atm), ] # look at NAs
summary(factor(atm$ATM)[!is.na(atm$Cash) & atm$Cash %% 1 != 0]) # not integers?
```

This is a time series spanning May 1, 2009 to April 30, 2010. The time series contains cash transaction amounts for four ATMs. The cash transactions have missing values and skewed distribution since the mean is higher than the third quartile. There are also non-integer transactions at ATM 4 implying that these data may represent debit card purchase.

### Visualizations

Visualizations consists of Time Plots, Histograms, ACF, and PACF plots. 

#### Time Plot and Histogram

The *Time Plot* is a line graph that plots each observed value against the time of the observation, with a single line connecting each observation across the entire period. The *Histogram* displays the frequency at which values occur. 

```{r warning=F, message=F, fig.align='center', cache=T}
par(mfrow=c(4, 2), mar = c(3, 5, 0, 0), oma = c(0, 0, 0.5, 0.5))
for(i in 1:length(levels(atm$ATM))) {
  atm_sub <- subset(atm, ATM == paste0("ATM", i))
  atm_ts <- xts::xts(atm_sub$Cash, order.by=atm_sub$DATE)
  n <- nrow(atm_ts); l <- rep(1, n); m <- rep(20, n); h <- rep(100, n)
  print(plot(cbind(atm_ts, l, m,h), main=paste0("ATM", i)))
  hist(atm_ts, col="steelblue", xlab="", main="")
}
```

The Time Plots and Histograms for ATM1 and ATM2 are unremarkable. The Time Plot and Histogram of ATM3 shows the data consists mostly of zero values with a handful of transactions occurring at the end of the series. ATM3 will not be modelled due to these degenerative properties. The Time Plot and Histogram of ATM4 shows an extreme outlier around the three-quarter mark of the series. The horizontal lines in the Time Plots represent $1 (red), $20 (green), and $100 (blue).

#### ACF and PACF

The *ACF* plot shows the autocorrelations between each observation and its immediate predecessor (lagged observation). The *PACF* plot shows the autocorrelations between the current observation and each lagged observation individually. The ` xts::xts()`function converts data to a time series object which displays better in visualizations than time series objects created using other packages.

```{r warning=F, message=F, fig.align='center', cache=T}
par(mfrow=c(4, 2), mar = c(3, 5, 0, 0), oma = c(0, 0, 0.5, 0.5))
for(i in 1:length(levels(atm$ATM))) {
  atm_sub <- subset(atm, ATM == paste0("ATM", i))
  atm_ts <- xts::xts(atm_sub$Cash, order.by=atm_sub$DATE)
  acf(na.omit(atm_ts), ylab=paste0("ACF ATM", i), main="") 
  pacf(na.omit(atm_ts), ylab=paste0("PACF ATM", i), main="")
}
```

The ACF and PACF plots for ATM1, ATM2, and ATM3 show autocorrelation between each observation and its immediate predecessor and autocorrelation between the current observation and other individual lagged observations. The ACF and PACF plots for ATM3 however, are not reliable due to the dearth of observations. 

## Clean Data

Data are cleaned using ` forecast::tsclean()` and then converted to a time series object using the `ts()` function. The `tsclean()` function imputes nulls and removes outliers. The ` ts()`function converts data to a time series object which is compatible with the `forecast` package.

```{r warning=F, message=F, fig.align='center', cache=T}
for(i in 1:length(levels(atm$ATM))) {
  atm_num <- paste0("ATM", i)
  atm_sub <- subset(atm, ATM == atm_num, select=-2)
  atm_sub$Cash <- forecast::tsclean(atm_sub$Cash, replace.missing=T)
  assign(atm_num, ts(atm_sub$Cash, frequency = 7, start=start(atm_sub$DATE)))
}
```

The `frequency` parameter was selected in accordance with the documentation accompanying the `ts()` function:

> The value of argument frequency is used when the series is sampled an integral number of times in each unit time interval. For example, one could use a value of 7 for frequency when the data are sampled daily, and the natural time period is a week, or 12 when the data are sampled monthly and the natural time period is a year. Values of 4 and 12 are assumed in (e.g.) print methods to imply a quarterly and monthly series respectively.

### Examine Trend

A moving average smoother is helpful in examining what kind of trend is involved in a series. Moving average models should not be confused with moving average smoothing. A moving average model is used for forecasting future values while moving average smoothing is used for estimating the trend-cycle of past values. The `ma()` function computes a simple moving average smoother of a given time series.

```{r warning=F, message=F, fig.align='center', cache=T}
par(mfrow=c(3, 1), mar = c(0, 4, 0, 0), oma = c(0, 0, 0.5, 0.5))
plot(ATM1, col=8, xaxt = "n", ylab="ATM1")
lines(forecast::ma(ATM1, order=7), col=2)
lines(forecast::ma(ATM1, order=30), col=4)
plot(ATM2, col=8, xaxt = "n", ylab="ATM3")
lines(forecast::ma(ATM2, order=7), col=2)
lines(forecast::ma(ATM2, order=30), col=4)
plot(ATM4, col=8, xaxt = "n", ylab="ATM4")
lines(forecast::ma(ATM4, order=7), col=2)
lines(forecast::ma(ATM4, order=30), col=4)
```

The 7-day (week) and 30-day (month) moving average smoother line shows that the data for the ATMs have no apparent trend.

### Decomposition

The Decomposition Plot decomposes and plots the observed values, the underlying trend, seasonality, and randomness of the time series data.

```{r warning=F, message=F, fig.align='center', cache=T}
plot(decompose(ATM1))
plot(decompose(ATM2))
plot(decompose(ATM4))
```

Plotting the trend-cycle and seasonal indices computed by additive decomposition shows that the data have no apparent trend, seasonal fluctuations, and fairly random residuals.

### Dickey-Fuller Test

An augmented Dickey-Fuller unit root test evaluates if the data exhibit a Stationarity process with deterministic trend or a Stationarity process with stochastic trend.

```{r warning=F, message=F, fig.align='center', cache=T}
tseries::adf.test(ATM1)
tseries::adf.test(ATM2)
tseries::adf.test(ATM4)
```

The augmented Dickey-Fuller unit root test $p$-values are far below $\alpha=0.05$. Therefore, the null hypothesis that the model has unit roots is rejected. The data exhibit stochastic trend which suggests using regression (AR) in lieu of differencing. Autoregressive (AR) modeling acts like partial differencing when $\phi<1$. When $\phi=1$ the AR(1) model is like a first-order difference.

## Model Data

### Train-Test Split

The train and test sets are created by referencing rows by index.

```{r warning=F, message=F, fig.align='center', cache=T}
index_train <- 1:(length(ATM1) - 30)
ATM1_train <- ts(ATM1[index_train], frequency=7)
ATM1_test <- ts(ATM1[-index_train], frequency=7)
ATM2_train <- ts(ATM2[index_train], frequency=7)
ATM2_test <- ts(ATM2[-index_train], frequency=7)
ATM3_train <- ts(ATM3[index_train], frequency=7)
ATM3_test <- ts(ATM3[-index_train], frequency=7)
ATM4_train <- ts(ATM4[index_train], frequency=7)
ATM4_test <- ts(ATM4[-index_train], frequency=7)
```

The indexed rows for the test set are a window at the end of the times series the size of the desired prediction. The training set window is comprised of the complement of indexes.

### Transformation

The Augmented Dickey-Fuller Test supports the results that no differencing should be performed. The data will not be seasonal adjusted so that seasonal components evaluated by the model are reflected in predictions. Heteroskedasticity refers to the circumstance in which the variability of a variable is unequal across the range of values of a second variable. Box-Cox transformations can help to stabilize the variance of a time series. Some typical Box-Cox transformations are: $$-2\Rightarrow \frac { 1 }{ y_t^{ 2 } }, \quad -1\Rightarrow \frac { 1 }{ y_t }, \quad -0.5\Rightarrow \frac { 1 }{ \sqrt { y_t }  }, \quad 0\Rightarrow \log { \left( y_t \right)  }, \quad 0.5\Rightarrow \sqrt { y_t }, \quad 1\Rightarrow y_t, \quad 2\Rightarrow  y_t^{ 2 }$$

```{r warning=F, message=F, fig.align='center', cache=T}
(lambda1 <- forecast::BoxCox.lambda(ATM1_train))
(lambda2 <- forecast::BoxCox.lambda(ATM2_train))
(lambda4 <- forecast::BoxCox.lambda(ATM4_train))
```

The Box-Cox transformations suggested are around $\lambda=0.5$. This, more interpretable, rounding is suggestive of a ${ 1 }/{ \sqrt { y_t } }$ transformation. This Box-Cox transformation stabilizes the variance and makes the series look relatively homoskedastic with equal variance. 

### ARIMA Model

The `auto.arima()` function chooses an ARIMA model automatically. It uses a variation of the Hyndman and Khandakar algorithm which combines unit root tests, minimization of the AICc, and MLE to obtain an ARIMA model. The function takes some short-cuts in order to speed up the computation and will not always yield the best model. Setting `stepwise` and `approximation` to `FALSE` prevents the function from taking short-cuts. 

```{r warning=F, message=F, fig.align='center', cache=T}
(fit1 <- forecast::auto.arima(ATM1_train, stepwise=F, approximation=F, d=0, lambda=lambda1))
(fit2 <- forecast::auto.arima(ATM2_train, stepwise=F, approximation=F, d=0, lambda=lambda2))
(fit4 <- forecast::auto.arima(ATM4_train, stepwise=F, approximation=F, d=0, lambda=lambda4))
```

The `auto.arima()` function suggests an $\textrm{ARIMA}(0,0,1)(2,0,0)_{7}$  model for ATM1, an $\textrm{ARIMA}(0,0,0)(2,0,0)_{7}$ model for ATM2, and an $\textrm{ARIMA}(1,0,0)(2,0,0)_{7}$ model for ATM4. 

## Evaluate Model

### ACF and PACF

The *ACF* plot shows the autocorrelations between each observation and its immediate predecessor (lagged observation). The *PACF* plot shows the autocorrelations between the current observation and each lagged observation individually.

```{r warning=F, message=F, fig.align='center', cache=T}
par(mfrow=c(3, 2), mar = c(3, 5, 0, 0), oma = c(0, 0, 0.5, 0.5))
acf(residuals(fit1), ylab="ACF ATM1"); pacf(residuals(fit1), ylab="PACF ATM1")
acf(residuals(fit2), ylab="ACF ATM2"); pacf(residuals(fit2), ylab="PACF ATM2")
acf(residuals(fit4), ylab="ACF ATM4"); pacf(residuals(fit4), ylab="PACF ATM4")
```

The residuals of the models appear to display the characteristics of White Noise in the ACF and PACF plots with only one of the twenty residuals (or 0.05%) being significant. At a 95% confidence interval this is within probabilistic expectations.

### Box-Ljung Test

The Box-Ljung test is helpful in assessing if data follow a White Noise pattern. The `arma` parameter of the fit returns a vector containing the ARIMA model parameters $p$, $q$, $P$, $Q$, period, $d$, and $D$ in that order.

```{r warning=F, message=F, fig.align='center', cache=T}
Box.test(residuals(fit1), lag=7, fitdf=sum(fit1$arma[1:2]), type="Ljung-Box")
Box.test(residuals(fit2), lag=7, fitdf=sum(fit1$arma[1:2]), type="Ljung-Box")
Box.test(residuals(fit4), lag=7, fitdf=sum(fit1$arma[1:2]), type="Ljung-Box")
```

The null hypothesis of independence is not rejected. The Box-Ljung shows that the autocorrelations of the residuals from the models are not significantly different from zero. The residuals of the models display the characteristics of White Noise. The models pass the required checks and are therefore suitable for forecasting.

## Forecast

ATM3 was not modelled due to its degenerative properties. To forecast values for ATM3, the model for an ATM with a similar mean will be used.

```{r warning=F, message=F, fig.align='center', cache=T}
c(mean(ATM1), mean(ATM2), mean(ATM3[ATM3!=0]), mean(ATM4))
```

The mean of ATM1 is very close to the mean of the few values in ATM3. Therefore, the $\textrm{ARIMA}(0,0,1)(2,0,0)_{7}$  model for ATM1 will be used to make predictions for ATM3.

```{r warning=F, message=F, fig.align='center', cache=T}
fit3 <- forecast::Arima(ATM3_train, model=fit1)
```

### In-Sample

Forecasts are done using the `forecast::forecast()` function. Since the data were not seasonally adjusted, they need not be "reseasonalized" prior to forecast. Prediction point estimates are represented by a blue line, prediction intervals are represented by blue bands, and actual values are represented by a red line.

```{r warning=F, message=F, fig.align='center', cache=T}
fcast1 <- forecast::forecast(fit1, h=30)
fcast2 <- forecast::forecast(fit2, h=30)
fcast3 <- forecast::forecast(fit3, h=30)
fcast4 <- forecast::forecast(fit4, h=30)
par(mfrow=c(4, 1), mar = c(0, 4, 0, 0), oma = c(4, 4, 2, 0.5))
plot(fcast1, ylab="Cash ATM1", main="", xaxt="n"); 
lines(lag(ATM1_test, -length(ATM1_train)), col="red")
plot(fcast2, ylab="Cash ATM2", main="", xaxt="n"); 
lines(lag(ATM2_test, -length(ATM2_train)), col="red")
plot(fcast3, ylab="Cash ATM3", main="", xaxt="n")
lines(lag(ATM3_test, -length(ATM3_train)), col="red")
plot(fcast4, ylab="Cash ATM4", main="", xaxt="n")
lines(lag(ATM4_test, -length(ATM4_train)), col="red")
title("ATM Predictions", outer=TRUE)
```

The predictions appear to produce a useful forecasts that reflect patterns in the original data. 

### Model Accuracy

The accuracy() function is helful for obtaining summary measures of the forecast accuracy: Mean Error (ME), Root Mean Squared Error (RMSE), Mean Absolute Error (MAE), Mean Percentage Error (MPE), Mean Absolute Percentage Error (MAPE), Mean Absolute Scaled Error (MASE), and Autocorrelation of errors at lag 1 (ACF1).

```{r warning=F, message=F, fig.align='center', cache=T}
round(forecast::accuracy(fcast1, length(ATM1_test)), 3)
round(forecast::accuracy(fcast2, length(ATM2_test)), 3)
round(forecast::accuracy(fcast4, length(ATM4_test)), 3)
```

These accuracy for the predications vary. ATM1 and ATM2 predictions are more accurate than AT4 predictions. The closer the original data were to being White Noise, the less accurate the predictions. 

### Out-of-Sample

Forecasts are done using the `forecast::forecast()` function. Since the data were not seasonally adjusted, they need not be "reseasonalized" prior to forecast.  These out-of-sample predictions and for exporting.

```{r warning=F, message=F, fig.align='center', cache=T}
fcast1 <- forecast::forecast(forecast::Arima(ATM1, model=fit1), h=30)
fcast2 <- forecast::forecast(forecast::Arima(ATM2, model=fit2), h=30)
fcast3 <- forecast::forecast(forecast::Arima(ATM3, model=fit1), h=30)
fcast4 <- forecast::forecast(forecast::Arima(ATM4, model=fit4), h=30)
```

## Export Results

Results are exported to an Excel file using the ` xlsx::write.xlsx()` function which includes an option for appending a worksheet to an existing file.

```{r warning=F, message=F, cache=T}
xlsx::write.xlsx(fcast1, file="DATA624_Project1.xlsx", 
  sheetName="ATM1", col.names = T, row.names = T, append = F)
xlsx::write.xlsx(fcast2, file="DATA624_Project1.xlsx", 
  sheetName="ATM2", col.names = T, row.names = T, append = T)
xlsx::write.xlsx(fcast3, file="DATA624_Project1.xlsx", 
  sheetName="ATM3", col.names = T, row.names = T, append = T)
xlsx::write.xlsx(fcast4, file="DATA624_Project1.xlsx", 
  sheetName="ATM4", col.names = T, row.names = T, append = T)
```

```{r echo=F}
# Clear Memory
rm(list=ls())
```

# Power Forecast

Part B consists of a simple dataset of residential power usage for January 1998 until December 2013. Your assignment is to model these data and a monthly forecast for 2014. The data is given in a single file. The variable `KWH` is power consumption in Kilowatt hours, the rest is straight forward. Add this to your existing files above.

## Import Data

There are several packages for importing Excel files into R. The native method in `r R.Version()$version.string` uses the `readxl` package. The `readxl` library translates Excel cell/column `date` types into R `POSIXct` types. This enhanced date format is not compatible with the current version of many packages. The `read.xls()` function from the ` openxlsx` package does not currently support https. It therefore requires use of `gsub()`. The `xlsx` package is versatile and has a function to write files which is needed for exporting results.

```{r warning=F, message=F, cache=T}
github <- "https://raw.githubusercontent.com/jzuniga123"
file <- "/SPS/master/DATA%20624/ResidentialCustomerForecastLoad-624.xlsx"
download.file(paste0(github, file), "temp.xlsx", mode="wb")
power <- xlsx::read.xlsx("temp.xlsx", sheetIndex=1, header=T)
power$YYYY.MMM <- as.Date(paste0(power$YYYY.MMM,"-01"), format = "%Y-%b-%d")
invisible(file.remove("temp.xlsx"))
```

The ambiguous "YYYY-MMM" format dates in this file are interpreted as factors. They must be converted to dates.

## Explore Data

The Time Series data are first explored through number summaries and visualizations.

### Number Summaries

The `summary()` function provides descriptive statistics on quantitative and qualitative variables. The `xts::preiodocity()` function describes the periods of the dates in the time series. The `complete.cases()` function returns observations in the datasets that have no missing values.

```{r warning=F, message=F, fig.align='center', cache=T}
summary(power)
xts::periodicity(unique(power$YYYY.MMM)) # sampling Frequency
power[!complete.cases(power), ] # look at NAs
```

### Visualizations

Visualizations consists of Time Plots, Histograms, ACF, and PACF plots. The *Time Plot* is a line graph that plots each observed value against the time of the observation, with a single line connecting each observation across the entire period. The *Histogram* displays the frequency at which values occur. 

```{r warning=F, message=F, fig.align='center', cache=T}
kWh <- xts::xts(power$KWH, order.by=power$YYYY.MMM)
par(mfrow=c(2, 1), mar = c(3, 5, 0, 0), oma = c(0, 0, 0.5, 0.5))
plot(kWh, main="kWh")
hist(kWh, col="steelblue", xlab="", main="")
```

The *ACF* plot shows the autocorrelations between each observation and its immediate predecessor (lagged observation). The *PACF* plot shows the autocorrelations between the current observation and each lagged observation individually. The ` xts::xts()`function converts data to a time series object which displays better in visualizations than time series objects created using other packages.

```{r warning=F, message=F, fig.align='center', cache=T}
par(mfrow=c(2, 1), mar = c(3, 5, 0, 0), oma = c(0, 0, 0.5, 0.5))
acf(na.omit(kWh), ylab="kWh", main="") 
pacf(na.omit(kWh), ylab="kWh", main="")
```

## Clean Data

Remove Outliers, NAs. 

>The value of argument frequency is used when the series is sampled an integral number of times in each unit time interval. For example, one could use a value of 7 for frequency when the data are sampled daily, and the natural time period is a week, or 12 when the data are sampled monthly and the natural time period is a year. Values of 4 and 12 are assumed in (e.g.) print methods to imply a quarterly and monthly series respectively.

```{r warning=F, message=F, fig.align='center', cache=T}
kWh <- ts(forecast::tsclean(power$KWH, replace.missing=T), 
          frequency = 12, start=start(power$YYYY.MMM))
kWh[kWh==min(kWh)] <- mean(kWh) # outlier wasnt removed
```

### Examine Trend

MA Smoothing --- looks absent/stochastic

```{r warning=F, message=F, fig.align='center', cache=T}
plot(kWh, col=8, xaxt = "n", ylab="ATM1")
lines(forecast::ma(kWh, order=6), col=2)
lines(forecast::ma(kWh, order=12), col=4)
```

### Decomposition

```{r warning=F, message=F, fig.align='center', cache=T}
plot(decompose(kWh))
```

### Dickey-Fuller Test

null hypothesis is non-stationarity (deterministic trend). If stochastic, do not difference.

```{r warning=F, message=F, fig.align='center', cache=T}
tseries::adf.test(kWh)
```

## Model Data

### Train-Test Split

```{r warning=F, message=F, fig.align='center', cache=T}
index_train <- 1:(length(kWh) - 12)
kWh_train <- ts(kWh[index_train], frequency=12)
kWh_test <- ts(kWh[-index_train], frequency=12)
```

### Transformation

no forecast::seasadj(ATM1w) since should be included in model
no diff(ATM1w) after due to adf test

```{r warning=F, message=F, fig.align='center', cache=T}
(lambda <- forecast::BoxCox.lambda(kWh_train))
```

### ARIMA Model

ARIMA Model. The number of seasonal differences is sometimes poorly chosen. If your data shows strong seasonality, try setting D=1 rather than relying on the automatic selection of D.

```{r warning=F, message=F, fig.align='center', cache=T}
(fit <- forecast::auto.arima(kWh_train, stepwise=F, approximation=F, d=0, lambda=lambda))
```

## Evaluate Model

### ACF and PACF

```{r warning=F, message=F, fig.align='center', cache=T}
par(mfrow=c(2, 1), mar = c(3, 5, 0, 0), oma = c(0, 0, 0.5, 0.5))
acf(residuals(fit), ylab="ACF kWh"); pacf(residuals(fit), ylab="PACF kWh")
```

### Box-Ljung Test

null hypothesis independce (white noise)
arma: p,q,P,Q,period,d,D

```{r warning=F, message=F, fig.align='center', cache=T}
Box.test(residuals(fit), lag=7, fitdf=sum(fit$arma[1:2]), type="Ljung-Box")
```

## Forecast

### In-Sample

```{r warning=F, message=F, fig.align='center', cache=T}
fcast <- forecast::forecast(fit, h=12)
plot(fcast, ylab="kWh", main="kWh Predictions", xaxt="n")
lines(lag(kWh_test, -length(kWh_train)), col="red")
```

### Model Accuracy

```{r warning=F, message=F, fig.align='center', cache=T}
round(forecast::accuracy(fcast, length(kWh_test)), 3)
```

### Out-of-Sample

```{r warning=F, message=F, fig.align='center', cache=T}
fcast <- forecast::forecast(forecast::Arima(kWh, model=fit), h=12)
```

## Export Results

```{r warning=F, message=F, cache=T}
xlsx::write.xlsx(fcast, file="DATA624_Project1.xlsx", 
  sheetName="kWh", col.names = T, row.names = T, append = T)
```

```{r echo=F}
# Clear Memory
rm(list=ls())
```

# Waterflow Forecast

Part C consists of two data sets.  These are simple 2 columns sets, however they have different time stamps.  Your optional assignment is to time-base sequence the data and aggregate based on hour (example of what this looks like, follows).  Note for multiple recordings within an hour, take the mean.  Then to determine if the data is stationary and can it be forecast.  If so, provide a week forward forecast and present results as above in a Word readable file and the forecast in an Excel readable file.

## Import Data

There are several packages for importing Excel files into R. The native method in `r R.Version()$version.string` uses the `readxl` package. The `readxl` library translates Excel cell/column `date` types into R `POSIXct` types. This enhanced date format is not compatible with the current version of many packages. The `read.xls()` function from the ` openxlsx` package does not currently support https. It therefore requires use of `gsub()`. The `xlsx` package is versatile and has a function to write files which is needed for exporting results.

```{r warning=F, message=F, cache=T}
github <- "https://raw.githubusercontent.com/jzuniga123"
file <- "/SPS/master/DATA%20624/Waterflow_Pipe1.xlsx"
download.file(paste0(github, file), "temp.xlsx", mode="wb")
pipe1 <- xlsx::read.xlsx("temp.xlsx", sheetIndex=1, header=T)
file <- "/SPS/master/DATA%20624/Waterflow_Pipe2.xlsx"
download.file(paste0(github, file), "temp.xlsx", mode="wb")
pipe2 <- xlsx::read.xlsx("temp.xlsx", sheetIndex=1, header=T)
invisible(file.remove("temp.xlsx"))
```

## Explore Data

The Time Series data are first explored through number summaries and visualizations.

### Number Summaries

The `summary()` function provides descriptive statistics on quantitative and qualitative variables. The `xts::preiodocity()` function describes the periods of the dates in the time series. The `complete.cases()` function returns observations in the datasets that have no missing values.

```{r warning=F, message=F, fig.align='center', cache=T}
summary(pipe1)
summary(pipe2)
xts::periodicity(unique(pipe1$Date.Time)) # sampling Frequency
xts::periodicity(unique(pipe2$Date.Time)) # sampling Frequency
```

## Sequence

```{r warning=F, message=F, fig.align='center', cache=T}
Pipe1 <- xts::xts(pipe1$WaterFlow, order.by=pipe2$Date.Time)
Pipe1h <- xts::period.apply(Pipe1, xts::endpoints(Pipe1, "hours"), mean)
xts::periodicity(Pipe1h)
```

## Aggregate

```{r warning=F, message=F, fig.align='center', cache=T}
Pipe2 <- xts::xts(pipe2$WaterFlow, order.by=pipe2$Date.Time)
Pipes <- merge(merge(Pipe1, Pipe2, join='inner'), Pipe1+Pipe2, join='inner')
head(Pipes)
```

### Visualizations

Visualizations consists of Time Plots, Histograms, ACF, and PACF plots. The *Time Plot* is a line graph that plots each observed value against the time of the observation, with a single line connecting each observation across the entire period. The *Histogram* displays the frequency at which values occur. 

```{r warning=F, message=F, fig.align='center', cache=T}
par(mfrow=c(3, 2), mar = c(3, 5, 0, 0), oma = c(0, 0, 0.5, 0.5))
plot(Pipe1, main="Pipe 1")
hist(Pipe1, col="steelblue", xlab="", main="")
plot(Pipe1h, main="Pipe 1 Hourly")
hist(Pipe1h, col="steelblue", xlab="", main="")
plot(Pipe2, main="Pipe 2")
hist(Pipe2, col="steelblue", xlab="", main="")
```

The *ACF* plot shows the autocorrelations between each observation and its immediate predecessor (lagged observation). The *PACF* plot shows the autocorrelations between the current observation and each lagged observation individually. The ` xts::xts()`function converts data to a time series object which displays better in visualizations than time series objects created using other packages.

```{r warning=F, message=F, fig.align='center', cache=T}
par(mfrow=c(3, 2), mar = c(3, 5, 0, 0), oma = c(0, 0, 0.5, 0.5))
acf(Pipe1, ylab="ACF Pipe 1", main="") 
pacf(Pipe1, ylab="PACF Pipe 1", main="")
acf(Pipe1h, ylab="ACF Pipe 1 Hourly", main="") 
pacf(Pipe1h, ylab="PACF Pipe 1 Hourly", main="")
acf(Pipe2, ylab="ACF Pipe 2", main="") 
pacf(Pipe2, ylab="PACF Pipe 2", main="")
```

## Clean Data

Remove Outliers, NAs. 

>The value of argument frequency is used when the series is sampled an integral number of times in each unit time interval. For example, one could use a value of 7 for frequency when the data are sampled daily, and the natural time period is a week, or 12 when the data are sampled monthly and the natural time period is a year. Values of 4 and 12 are assumed in (e.g.) print methods to imply a quarterly and monthly series respectively.

```{r warning=F, message=F, fig.align='center', cache=T}
Pipe1 <- ts(Pipe1h, frequency = 12, start=start(Pipe1h))
Pipe2 <- ts(pipe2$WaterFlow, frequency = 12, start=start(pipe2$Date.Time))
```

### Examine Trend

MA Smoothing --- looks absent/stochastic

```{r warning=F, message=F, fig.align='center', cache=T}
par(mfrow=c(2, 1), mar = c(0, 4, 0, 0), oma = c(0, 0, 0.5, 0.5))
plot(Pipe1, col=8, xaxt = "n", ylab="Pipe 1 Hourly")
lines(forecast::ma(Pipe1, order=7), col=2)
lines(forecast::ma(Pipe1, order=30), col=4)
plot(Pipe2, col=8, xaxt = "n", ylab="Pipe 2")
lines(forecast::ma(Pipe2, order=7), col=2)
lines(forecast::ma(Pipe2, order=30), col=4)
```

### Decomposition

```{r warning=F, message=F, fig.align='center', cache=T}
plot(decompose(Pipe1))
plot(decompose(Pipe2))
```

### Dickey-Fuller Test

null hypothesis is non-stationarity (deterministic trend). If stochastic, do not difference.

```{r warning=F, message=F, fig.align='center', cache=T}
tseries::adf.test(Pipe1)
tseries::adf.test(Pipe2)
```

## Model Data

### Train-Test Split

```{r warning=F, message=F, fig.align='center', cache=T}
index_train <- 1:(length(Pipe1) - 24*7)
Pipe1_train <- ts(Pipe1[index_train], frequency=12)
Pipe1_test <- ts(Pipe1[-index_train], frequency=12)
index_train <- 1:(length(Pipe2) - 24*7)
Pipe2_train <- ts(Pipe2[index_train], frequency=12)
Pipe2_test <- ts(Pipe2[-index_train], frequency=12)
```

### Transformation

no forecast::seasadj(ATM1w) since should be included in model
no diff(ATM1w) after due to adf test

```{r warning=F, message=F, fig.align='center', cache=T}
(lambda1 <- forecast::BoxCox.lambda(Pipe1_train))
(lambda2 <- forecast::BoxCox.lambda(Pipe2_train))
```

### ARIMA Model

ARIMA Model. The number of seasonal differences is sometimes poorly chosen. If your data shows strong seasonality, try setting D=1 rather than relying on the automatic selection of D.

```{r warning=F, message=F, fig.align='center', cache=T}
(fit1 <- forecast::auto.arima(Pipe1_train, stepwise=F, approximation=F, d=0, lambda=lambda1))
(fit2 <- forecast::auto.arima(Pipe2_train, stepwise=F, approximation=F, d=0, lambda=lambda2))
```

## Evaluate Model

### ACF and PACF

```{r warning=F, message=F, fig.align='center', cache=T}
par(mfrow=c(2, 2), mar = c(3, 5, 0, 0), oma = c(0, 0, 0.5, 0.5))
acf(residuals(fit1), ylab="ACF Pipe 1"); pacf(residuals(fit1), ylab="PACF Pipe 1")
acf(residuals(fit2), ylab="ACF Pipe 2"); pacf(residuals(fit2), ylab="PACF Pipe 2")
```

### Box-Ljung Test

null hypothesis independce (white noise)
arma: p,q,P,Q,period,d,D

```{r warning=F, message=F, fig.align='center', cache=T}
Box.test(residuals(fit1), lag=7, fitdf=sum(fit1$arma[1:2]), type="Ljung-Box")
Box.test(residuals(fit2), lag=7, fitdf=sum(fit1$arma[1:2]), type="Ljung-Box")
```

## Forecast

### In-Sample

```{r warning=F, message=F, fig.align='center', cache=T}
fcast1 <- forecast::forecast(fit1, h=24*7)
fcast2 <- forecast::forecast(fit2, h=24*7)
par(mfrow=c(2, 1), mar = c(0, 4, 0, 0), oma = c(4, 4, 2, 0.5))
plot(fcast1, ylab="Waterflow Pipe 1", main="", xaxt="n")
lines(lag(Pipe1_test, -length(Pipe1_train)), col="red")
plot(fcast2, ylab="Waterflow Pipe 2", main="", xaxt="n")
lines(lag(Pipe2_test, -length(Pipe2_train)), col="red")
title("Waterflow Predictions", outer=TRUE)
```

### Model Accuracy

```{r warning=F, message=F, fig.align='center', cache=T}
round(forecast::accuracy(fcast1, length(Pipe1_test)), 3)
round(forecast::accuracy(fcast2, length(Pipe2_test)), 3)
```

### Out-of-Sample

```{r warning=F, message=F, fig.align='center', cache=T}
fcast1 <- forecast::forecast(forecast::Arima(Pipe1, model=fit1), h=30)
fcast2 <- forecast::forecast(forecast::Arima(Pipe2, model=fit2), h=30)
```

## Export Results

```{r warning=F, message=F, cache=T}
xlsx::write.xlsx(fcast1, file="DATA624_Project1.xlsx", 
  sheetName="Pipe1", col.names = T, row.names = T, append = T)
xlsx::write.xlsx(fcast2, file="DATA624_Project1.xlsx", 
  sheetName="Pipe2", col.names = T, row.names = T, append = T)
xlsx::write.xlsx(Pipes, file="DATA624_Project1.xlsx", 
  sheetName="PipeMerge", col.names = T, row.names = T, append = T)
```

```{r echo=F}
# Clear Memory
rm(list=ls())
```

# References

https://www.otexts.org/fpp/

http://rpubs.com/josezuniga/282349

http://rpubs.com/josezuniga/358602

http://rpubs.com/josezuniga/362102

http://rpubs.com/josezuniga/363796

http://rpubs.com/josezuniga/366918

https://www.statmethods.net/input/dates.html

https://www.statmethods.net/advstats/timeseries.html

http://readxl.tidyverse.org/articles/cell-and-column-types.html

https://www.rdocumentation.org/packages/stats/versions/3.4.3/topics/ts

https://github.com/hannarud/r-best-practices/wiki/Installing-RJava-(Ubuntu)

https://s3.amazonaws.com/assets.datacamp.com/blog_assets/xts_Cheat_Sheet_R.pdf

https://www.today.com/money/forget-20-minimum-atms-dispense-1-5-bills-1B8050058

https://www.valuepenguin.com/banking/atm-withdrawal-limits-daily-debit-purchase-limit

https://www.datascience.com/blog/introduction-to-forecasting-with-arima-in-r-learn-data-science-tutorials
